<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAL Assessment Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }

        .app {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            height: 100vh;
            gap: 1px;
            background: #ddd;
        }

        .panel {
            background: white;
            padding: 20px;
            overflow-y: auto;
        }

        .map-container {
            position: relative;
            background: #e9ecef;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        h1, h2, h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        h1 {
            font-size: 1.5em;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 10px;
        }

        .section {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #34495e;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            margin: 5px 0;
            transition: background 0.3s;
        }

        button:hover {
            background: #2980b9;
        }

        .calculate-btn {
            background: #e74c3c;
            font-size: 16px;
            font-weight: bold;
            padding: 15px;
        }

        .calculate-btn:hover {
            background: #c0392b;
        }

        .veg-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }

        .veg-btn {
            background: #27ae60;
            font-size: 12px;
            padding: 8px;
        }

        .veg-btn:hover {
            background: #219a52;
        }

        .active-drawing {
            background: #e74c3c !important;
            border: 2px solid #c0392b;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 14px;
        }

        .results-table th,
        .results-table td {
            border: 1px solid #bdc3c7;
            padding: 8px;
            text-align: left;
        }

        .results-table th {
            background: #34495e;
            color: white;
        }

        .bal-low { background: #27ae60; color: white; }
        .bal-12p5 { background: #f39c12; color: white; }
        .bal-19 { background: #e67e22; color: white; }
        .bal-29 { background: #e74c3c; color: white; }
        .bal-fz { background: #c0392b; color: white; }

        .disclaimer {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-size: 12px;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .map-controls button {
            width: auto;
            margin: 2px;
            padding: 8px 12px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #3498db;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }

        .export-btn {
            background: #9b59b6;
            font-size: 12px;
            padding: 8px;
        }

        .export-btn:hover {
            background: #8e44ad;
        }

        .feature-info {
            background: #e8f4fd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- Left Panel - Inputs -->
        <div class="panel left-panel">
            <h1>BAL Assessment Tool</h1>
            
            <div class="section">
                <h3>üìç Site Location</h3>
                <div class="input-group">
                    <label>Address Search</label>
                    <input type="text" id="addressInput" placeholder="Enter address...">
                    <button onclick="geocodeAddress()">Search Location</button>
                </div>
                <div id="locationInfo" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
            </div>

            <div class="section">
                <h3>üè† Property Boundary</h3>
                <p style="font-size: 14px; color: #666; margin-bottom: 10px;">Draw your property boundary on the map</p>
                <button id="drawPropertyBtn" onclick="startDrawingProperty()">Draw Property</button>
                <div id="propertyInfo" class="feature-info" style="display: none;">
                    Property boundary drawn ‚úì
                </div>
            </div>

            <div class="section">
                <h3>üå≥ Vegetation</h3>
                <p style="font-size: 14px; color: #666; margin-bottom: 10px;">Draw vegetation areas and assign classes:</p>
                <div class="veg-buttons">
                    <button class="veg-btn" onclick="startDrawingVegetation('forest')">Forest</button>
                    <button class="veg-btn" onclick="startDrawingVegetation('woodland')">Woodland</button>
                    <button class="veg-btn" onclick="startDrawingVegetation('scrub')">Scrub</button>
                    <button class="veg-btn" onclick="startDrawingVegetation('grassland')">Grassland</button>
                </div>
                <div id="vegetationInfo" class="feature-info" style="display: none;">
                    Vegetation areas drawn: <span id="vegCount">0</span>
                </div>
            </div>

            <div class="section">
                <h3>‚õ∞Ô∏è Site Slope</h3>
                <div class="input-group">
                    <label>Slope Percentage</label>
                    <input type="number" id="slopeInput" value="10" min="0" max="100" step="1">
                </div>
                <button onclick="measureSlope()">Measure Slope on Map</button>
            </div>

            <div class="section">
                <h3>üî• Fire Danger</h3>
                <div class="input-group">
                    <label>FFDI Value</label>
                    <select id="ffdiSelect">
                        <option value="50">Moderate (50)</option>
                        <option value="80" selected>High (80)</option>
                        <option value="100">Very High (100)</option>
                        <option value="120">Extreme (120)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label style="display: inline-block; margin-right: 10px;">
                        <input type="checkbox" id="fuelReduction"> Fuel Reduction Applied
                    </label>
                </div>
            </div>

            <button class="calculate-btn" onclick="calculateBAL()">Calculate BAL</button>

            <div class="disclaimer">
                <strong>Disclaimer:</strong> This is a screening tool only. Not suitable for regulatory purposes. 
                Always consult accredited bushfire consultants for formal assessments.
            </div>
        </div>

        <!-- Center Panel - Map -->
        <div class="map-container">
            <div id="map"></div>
            <div class="map-controls">
                <button onclick="clearAll()">Clear Map</button>
                <button onclick="toggleVegetation()">Toggle Vegetation</button>
            </div>
        </div>

        <!-- Right Panel - Results -->
        <div class="panel right-panel">
            <h2>Results</h2>
            <div id="resultsContent">
                <div style="text-align: center; color: #666; padding: 40px 20px;">
                    <p>üëÜ <strong>Getting Started:</strong></p>
                    <p>1. Search for your location</p>
                    <p>2. Click "Draw Property" and draw on map</p>
                    <p>3. Click vegetation buttons and draw areas</p>
                    <p>4. Click "Calculate BAL"</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script>
        // Global variables
        let map;
        let drawnItems;
        let drawControl;
        let currentDrawingType = null;
        let propertyLayer = null;
        let vegetationLayers = [];
        let activeVegetationButton = null;

        // Vegetation classes with parameters
        const vegetationClasses = {
            'forest': { 
                name: 'Forest', 
                fuelLoad: 20, 
                height: 20, 
                color: '#228B22',
                description: 'Tall trees >20m, heavy fuel load'
            },
            'woodland': { 
                name: 'Woodland', 
                fuelLoad: 15, 
                height: 10, 
                color: '#32CD32',
                description: 'Medium trees 10-20m, moderate fuel'
            },
            'scrub': { 
                name: 'Scrub', 
                fuelLoad: 10, 
                height: 4, 
                color: '#90EE90',
                description: 'Shrubs 2-6m, moderate fuel'
            },
            'grassland': { 
                name: 'Grassland', 
                fuelLoad: 5, 
                height: 1, 
                color: '#ADFF2F',
                description: 'Grasses <2m, light fuel'
            }
        };

        // Initialize the map
        function initMap() {
            map = L.map('map').setView([-37.8136, 144.9631], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Initialize feature group to store drawn items
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // Initialize draw control
            drawControl = new L.Control.Draw({
                edit: {
                    featureGroup: drawnItems
                },
                draw: {
                    polygon: {
                        allowIntersection: false,
                        showArea: true
                    },
                    rectangle: true,
                    circle: false,
                    marker: false,
                    polyline: false
                }
            });
            map.addControl(drawControl);

            // Handle draw events
            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                const type = e.layerType;
                
                if (currentDrawingType === 'property') {
                    // Remove previous property layer
                    if (propertyLayer) {
                        drawnItems.removeLayer(propertyLayer);
                    }
                    propertyLayer = layer;
                    layer.setStyle({
                        color: '#3498db',
                        fillColor: '#3498db',
                        fillOpacity: 0.2,
                        weight: 3
                    });
                    
                    // Add popup with area info
                    const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                    const areaHectares = (area / 10000).toFixed(2);
                    layer.bindPopup(`<b>Property Boundary</b><br>Area: ${areaHectares} hectares`);
                    
                    document.getElementById('propertyInfo').style.display = 'block';
                    
                } else if (currentDrawingType && currentDrawingType.startsWith('vegetation-')) {
                    const vegType = currentDrawingType.replace('vegetation-', '');
                    const vegClass = vegetationClasses[vegType];
                    
                    layer.vegetationType = vegType;
                    layer.setStyle({
                        color: vegClass.color,
                        fillColor: vegClass.color,
                        fillOpacity: 0.4,
                        weight: 2
                    });
                    
                    // Add popup with vegetation info
                    const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                    const areaHectares = (area / 10000).toFixed(2);
                    layer.bindPopup(`<b>${vegClass.name}</b><br>Area: ${areaHectares} ha<br>${vegClass.description}`);
                    
                    vegetationLayers.push(layer);
                    updateVegetationCount();
                }
                
                drawnItems.addLayer(layer);
                currentDrawingType = null;
                
                // Reset active button
                if (activeVegetationButton) {
                    activeVegetationButton.classList.remove('active-drawing');
                    activeVegetationButton = null;
                }
            });

            // Handle edit events
            map.on(L.Draw.Event.EDITED, function (e) {
                const layers = e.layers;
                layers.eachLayer(function (layer) {
                    // Update any custom properties if needed
                });
            });
        }

        // Start drawing property boundary
        function startDrawingProperty() {
            currentDrawingType = 'property';
            new L.Draw.Rectangle(map, {
                shapeOptions: {
                    color: '#3498db',
                    fillColor: '#3498db',
                    fillOpacity: 0.2,
                    weight: 3
                }
            }).enable();
        }

        // Start drawing vegetation
        function startDrawingVegetation(vegType) {
            const vegClass = vegetationClasses[vegType];
            currentDrawingType = 'vegetation-' + vegType;
            
            // Set active button state
            if (activeVegetationButton) {
                activeVegetationButton.classList.remove('active-drawing');
            }
            activeVegetationButton = event.target;
            activeVegetationButton.classList.add('active-drawing');
            
            new L.Draw.Rectangle(map, {
                shapeOptions: {
                    color: vegClass.color,
                    fillColor: vegClass.color,
                    fillOpacity: 0.4,
                    weight: 2
                }
            }).enable();
        }

        // Update vegetation count display
        function updateVegetationCount() {
            const count = vegetationLayers.length;
            document.getElementById('vegCount').textContent = count;
            document.getElementById('vegetationInfo').style.display = 'block';
        }

        // Geocode address
        async function geocodeAddress() {
            const address = document.getElementById('addressInput').value;
            if (!address) return;

            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`);
                const data = await response.json();
                
                if (data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lon = parseFloat(result.lon);
                    
                    map.setView([lat, lon], 15);
                    
                    // Add a marker
                    if (window.locationMarker) {
                        map.removeLayer(window.locationMarker);
                    }
                    window.locationMarker = L.marker([lat, lon]).addTo(map)
                        .bindPopup(`<b>Selected Location</b><br>${result.display_name}`)
                        .openPopup();
                    
                    document.getElementById('locationInfo').innerHTML = 
                        `<strong>Located:</strong> ${result.display_name}`;
                } else {
                    alert('Address not found');
                }
            } catch (error) {
                alert('Geocoding failed: ' + error.message);
            }
        }

        // Measure slope between two points
        function measureSlope() {
            alert('Slope measurement: Click two points on the map. For now, please enter slope value manually.');
            // In a full implementation, this would capture elevation data
        }

        // Main BAL calculation function
        function calculateBAL() {
            if (!propertyLayer) {
                alert('Please draw your property boundary first by clicking "Draw Property" and drawing on the map');
                return;
            }

            if (vegetationLayers.length === 0) {
                alert('Please draw at least one vegetation area by clicking the vegetation buttons and drawing on the map');
                return;
            }

            const slope = parseFloat(document.getElementById('slopeInput').value);
            const ffdi = parseInt(document.getElementById('ffdiSelect').value);
            const fuelReduction = document.getElementById('fuelReduction').checked;

            // Show loading
            document.getElementById('resultsContent').innerHTML = '<div class="loading">Calculating BAL... Please wait</div>';

            // Simulate calculation delay
            setTimeout(() => {
                const results = performBALCalculation(slope, ffdi, fuelReduction);
                displayResults(results);
                updateMapWithResults(results);
            }, 1500);
        }

        // Perform BAL calculations
        function performBALCalculation(slope, ffdi, fuelReduction) {
            const results = [];
            const directions = [
                { name: 'North', bearing: 0 },
                { name: 'Northeast', bearing: 45 },
                { name: 'East', bearing: 90 },
                { name: 'Southeast', bearing: 135 },
                { name: 'South', bearing: 180 },
                { name: 'Southwest', bearing: 225 },
                { name: 'West', bearing: 270 },
                { name: 'Northwest', bearing: 315 }
            ];
            
            // Get property center for distance calculations
            const propertyBounds = propertyLayer.getBounds();
            const propertyCenter = propertyBounds.getCenter();
            
            directions.forEach(direction => {
                // Calculate distance to nearest vegetation in this direction
                let minDistance = Infinity;
                let nearestVegType = 'forest';
                
                vegetationLayers.forEach(vegLayer => {
                    const vegBounds = vegLayer.getBounds();
                    const vegCenter = vegBounds.getCenter();
                    
                    // Simple distance calculation (in reality would be more sophisticated)
                    const distance = propertyCenter.distanceTo(vegCenter);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestVegType = vegLayer.vegetationType;
                    }
                });
                
                // Add some randomness for demo purposes
                minDistance = Math.max(20, minDistance + (Math.random() * 50 - 25));
                
                // Calculate radiant heat
                const radiantHeat = calculateRadiantHeat(minDistance, nearestVegType, slope, ffdi, fuelReduction);
                
                // Determine BAL category
                const balCategory = determineBALCategory(radiantHeat);
                
                results.push({
                    direction: direction.name,
                    bearing: direction.bearing,
                    distance: minDistance,
                    vegetation: nearestVegType,
                    balCategory: balCategory,
                    radiantHeat: radiantHeat
                });
            });

            return results;
        }

        // Calculate radiant heat (simplified empirical model)
        function calculateRadiantHeat(distance, vegType, slope, ffdi, fuelReduction) {
            const vegParams = vegetationClasses[vegType];
            let baseFuelLoad = vegParams.fuelLoad;
            
            if (fuelReduction) {
                baseFuelLoad *= 0.7; // 30% reduction
            }
            
            // Simplified radiant heat model based on distance and vegetation
            const slopeFactor = 1 + (slope / 100);
            const ffdiFactor = ffdi / 50;
            const distanceDecay = Math.exp(-0.02 * distance);
            
            let radiantHeat = (baseFuelLoad * slopeFactor * ffdiFactor * 30 * distanceDecay);
            
            return Math.min(Math.max(radiantHeat, 5), 80); // Cap between 5-80
        }

        // Determine BAL category
        function determineBALCategory(radiantHeat) {
            if (radiantHeat < 12.5) return 'BAL-LOW';
            if (radiantHeat < 19) return 'BAL-12.5';
            if (radiantHeat < 29) return 'BAL-19';
            if (radiantHeat < 40) return 'BAL-29';
            return 'BAL-FZ';
        }

        // Display results in right panel
        function displayResults(results) {
            let html = '<div class="section">';
            html += '<h3>Assessment Summary</h3>';
            
            // Find worst BAL
            const balOrder = { 'BAL-FZ': 5, 'BAL-29': 4, 'BAL-19': 3, 'BAL-12.5': 2, 'BAL-LOW': 1 };
            let worstBAL = 'BAL-LOW';
            
            results.forEach(result => {
                if (balOrder[result.balCategory] > balOrder[worstBAL]) {
                    worstBAL = result.balCategory;
                }
            });
            
            const balClass = worstBAL.toLowerCase().replace('bal-', '').replace('.', 'p');
            html += `<div style="text-align: center; padding: 15px; background: #e8f4fd; border-radius: 4px; margin-bottom: 15px;">
                        <strong>Overall Property Rating:</strong><br>
                        <span style="font-size: 24px; font-weight: bold;" class="bal-${balClass}">${worstBAL}</span>
                     </div>`;
            
            html += '</div>';
            
            html += '<div class="section">';
            html += '<h3>Detailed Results by Direction</h3>';
            html += '<table class="results-table">';
            html += '<tr><th>Direction</th><th>Distance (m)</th><th>Vegetation</th><th>BAL</th><th>Heat (kW/m¬≤)</th></tr>';
            
            results.forEach(result => {
                const balClass = result.balCategory.toLowerCase().replace('bal-', '').replace('.', 'p');
                const vegName = vegetationClasses[result.vegetation].name;
                html += `<tr>
                            <td>${result.direction}</td>
                            <td>${result.distance.toFixed(0)}</td>
                            <td>${vegName}</td>
                            <td class="bal-${balClass}">${result.balCategory}</td>
                            <td>${result.radiantHeat.toFixed(1)}</td>
                         </tr>`;
            });
            
            html += '</table>';
            html += '</div>';
            
            html += '<div class="section">';
            html += '<h3>Export Results</h3>';
            html += '<div class="export-buttons">';
            html += '<button class="export-btn" onclick="exportPDF()">PDF Report</button>';
            html += '<button class="export-btn" onclick="exportCSV()">CSV Data</button>';
            html += '<button class="export-btn" onclick="exportGeoJSON()">GeoJSON</button>';
            html += '</div>';
            html += '</div>';
            
            html += '<div class="disclaimer">';
            html += '<strong>Method Notes:</strong><br>';
            html += '‚Ä¢ Empirical radiant heat model based on vegetation class and distance<br>';
            html += '‚Ä¢ Slope enhancement factor applied<br>';
            html += '‚Ä¢ FFDI scaling for fire intensity<br>';
            html += '‚Ä¢ Screening tool only - consult accredited consultants';
            html += '</div>';
            
            document.getElementById('resultsContent').innerHTML = html;
        }

        // Update map with result visualization
        function updateMapWithResults(results) {
            // Add BAL direction indicators
            const propertyBounds = propertyLayer.getBounds();
            const propertyCenter = propertyBounds.getCenter();
            
            results.forEach(result => {
                // Create direction lines
                const endPoint = calculateDestinationPoint(propertyCenter, result.bearing, result.distance);
                const line = L.polyline([propertyCenter, endPoint], {
                    color: getColorForBAL(result.balCategory),
                    weight: 3,
                    opacity: 0.7
                }).addTo(map);
                
                // Add BAL label
                L.marker(endPoint).addTo(map)
                    .bindPopup(`<b>${result.direction}</b><br>BAL: ${result.balCategory}<br>Distance: ${result.distance.toFixed(0)}m`)
                    .openPopup();
            });
        }

        // Calculate destination point given start, bearing, and distance
        function calculateDestinationPoint(start, bearing, distance) {
            const R = 6371000; // Earth radius in meters
            const bearingRad = bearing * Math.PI / 180;
            const latRad = start.lat * Math.PI / 180;
            const lonRad = start.lng * Math.PI / 180;
            
            const newLat = Math.asin(Math.sin(latRad) * Math.cos(distance/R) + 
                           Math.cos(latRad) * Math.sin(distance/R) * Math.cos(bearingRad));
            const newLon = lonRad + Math.atan2(Math.sin(bearingRad) * Math.sin(distance/R) * Math.cos(latRad),
                           Math.cos(distance/R) - Math.sin(latRad) * Math.sin(newLat));
            
            return L.latLng(newLat * 180 / Math.PI, newLon * 180 / Math.PI);
        }

        // Get color for BAL category
        function getColorForBAL(balCategory) {
            switch(balCategory) {
                case 'BAL-LOW': return '#27ae60';
                case 'BAL-12.5': return '#f39c12';
                case 'BAL-19': return '#e67e22';
                case 'BAL-29': return '#e74c3c';
                case 'BAL-FZ': return '#c0392b';
                default: return '#999';
            }
        }

        // Export functions
        function exportPDF() {
            alert('PDF export would generate a report with:\n- Input parameters\n- BAL contour map\n- Results table\n- Method notes\n- Disclaimer');
        }

        function exportCSV() {
            const results = performBALCalculation(
                parseFloat(document.getElementById('slopeInput').value),
                parseInt(document.getElementById('ffdiSelect').value),
                document.getElementById('fuelReduction').checked
            );
            
            let csv = 'Direction,Bearing,Distance(m),Vegetation,BAL_Category,Radiant_Heat(kW/m2)\n';
            results.forEach(result => {
                csv += `${result.direction},${result.bearing},${result.distance.toFixed(1)},${result.vegetation},${result.balCategory},${result.radiantHeat.toFixed(1)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bal-assessment-results.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function exportGeoJSON() {
            alert('GeoJSON export would download all map features and BAL contours as a GeoJSON file.');
        }

        // Utility functions
        function clearAll() {
            drawnItems.clearLayers();
            vegetationLayers = [];
            propertyLayer = null;
            document.getElementById('propertyInfo').style.display = 'none';
            document.getElementById('vegetationInfo').style.display = 'none';
            document.getElementById('resultsContent').innerHTML = 
                '<div style="text-align: center; color: #666; padding: 40px 20px;">Map cleared. Draw your site to begin.</div>';
        }

        function toggleVegetation() {
            vegetationLayers.forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                } else {
                    map.addLayer(layer);
                }
            });
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            console.log('BAL Assessment Tool Loaded!');
            console.log('Now with working drawing functionality!');
        });
    </script>
</body>
</html>
